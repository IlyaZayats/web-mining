<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Модуль 7 — Тест по Go (30 вопросов)</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    .timer-badge { font-variant-numeric: tabular-nums; }
    .question-card { scroll-margin-top: 96px; }
  </style>
</head>
<body id="top">

<nav class="navbar navbar-expand-lg bg-white border-bottom sticky-top">
  <div class="container">
    <a class="navbar-brand fw-semibold" href="index.html">ЭУМК Go</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#topNav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="topNav">
      <ul class="navbar-nav ms-auto gap-1">
        <li class="nav-item"><a class="nav-link" href="index.html#structure">Модули</a></li>
        <li class="nav-item"><a class="nav-link" href="index.html#requirements">ПО</a></li>
      </ul>
    </div>
  </div>
</nav>

<main class="py-4">
  <div class="container">
    <nav aria-label="breadcrumb" class="mb-3">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Главная</a></li>
        <li class="breadcrumb-item active" aria-current="page">Модуль 7 — Тестирование</li>
      </ol>
    </nav>

    <!-- Test header -->
    <div class="card rounded-4 shadow-sm mb-4">
      <div class="card-body p-4 p-md-5">
        <div class="d-flex flex-wrap justify-content-between align-items-start gap-3">
          <div>
            <div class="badge text-bg-primary mb-2">Тип 2</div>
            <h1 class="h3 mb-1">Тест по Go: основы, I/O и конкурентность</h1>
            <p class="text-secondary mb-0">
              Тип теста: <strong>теоретический</strong>. Ответ на каждый вопрос — один вариант из четырёх.
            </p>
          </div>

          <div class="text-end">
            <div class="d-flex flex-wrap gap-2 justify-content-end">
              <span class="badge text-bg-light border text-dark">Вопросов: <span id="metaQuestions">30</span></span>
              <span class="badge text-bg-light border text-dark">Время: <span id="metaTime">20:00</span></span>
              <span class="badge text-bg-light border text-dark">Проходной балл: <span id="metaPass">70%</span></span>
              <span class="badge text-bg-info timer-badge" id="timerBadge">⏱ 20:00</span>
            </div>
          </div>
        </div>

        <hr class="my-4">

        <!-- Instructions -->
        <h2 class="h5 mb-3">Инструкции</h2>
        <ul class="text-secondary mb-4">
          <li>Нажми «Завершить», когда готов — или тест завершится автоматически по таймеру.</li>
          <li>Можно пропускать вопросы и вернуться позже.</li>
          <li>Засчитывается только один выбранный вариант ответа на вопрос.</li>
          <li>Кнопка «Начать заново» сбрасывает ответы и таймер.</li>
        </ul>

        <div class="d-flex flex-wrap gap-2">
          <button class="btn btn-outline-secondary" id="btnReset">Начать заново</button>
          <button class="btn btn-primary" id="btnFinish">Завершить</button>
        </div>
      </div>
    </div>

    <!-- Questions container -->
    <div id="questions"></div>

    <div class="mt-4 d-flex flex-wrap gap-2">
      <a class="btn btn-outline-secondary" href="index.html#structure">К модулям</a>
      <a class="btn btn-outline-primary" href="module-6.html">К предыдущему модулю</a>
    </div>
  </div>
</main>

<!-- Result modal -->
<div class="modal fade" id="resultModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content rounded-4">
      <div class="modal-header">
        <h5 class="modal-title">Результаты теста</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body">
        <div class="p-3 bg-light rounded-4">
          <div class="d-flex justify-content-between">
            <span class="text-secondary">Правильных:</span>
            <strong><span id="resCorrect">0</span>/<span id="resTotal">30</span></strong>
          </div>
          <div class="d-flex justify-content-between">
            <span class="text-secondary">Процент:</span>
            <strong><span id="resPercent">0</span>%</strong>
          </div>
          <div class="d-flex justify-content-between">
            <span class="text-secondary">Статус:</span>
            <strong id="resStatus">—</strong>
          </div>
        </div>

        <div class="alert alert-primary mt-3 mb-0 rounded-4" id="resHint"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline-secondary" data-bs-dismiss="modal">Закрыть</button>
        <a class="btn btn-primary" href="module-8.html">Следующий модуль</a>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
  // ====== CONFIG ======
  const TEST = {
    totalQuestions: 30,
    durationSec: 20 * 60, // 20 минут
    passPercent: 70,
    type: "теоретический"
  };

  // ====== QUESTIONS ======
  const questionsData = [{"id": 1, "text": "Какая команда инициализирует новый Go-модуль в текущей папке?", "options": ["go init", "go mod init", "go get", "go env"], "correctIndex": 1}, {"id": 2, "text": "Что означает шаблон пути './...' в командах go (например, 'go test ./...')?", "options": ["Только текущий файл", "Только текущий пакет", "Текущий пакет и все подпакеты рекурсивно", "Все зависимости из кэша модулей"], "correctIndex": 2}, {"id": 3, "text": "Какое утверждение про gofmt верно?", "options": ["Это необязательный линтер", "Он форматирует код по единому стандарту и считается обязательной практикой", "Он оптимизирует производительность", "Он генерирует документацию"], "correctIndex": 1}, {"id": 4, "text": "Какая особенность краткого объявления ':=' верна?", "options": ["Можно использовать только на уровне пакета", "Можно использовать только внутри функций", "Всегда требует явного типа справа", "Запрещено в if/for"], "correctIndex": 1}, {"id": 5, "text": "Что произойдет при попытке записать в nil-map: var m map[string]int; m[\"x\"]=1 ?", "options": ["Ничего, ключ добавится", "Будет panic", "Вернется error", "Запись проигнорируется"], "correctIndex": 1}, {"id": 6, "text": "Что копируется при присваивании одного среза другому: b := a ?", "options": ["Копируются все элементы массива", "Копируется только заголовок среза (указатель/len/cap)", "Создается новый backing array всегда", "Копируются только первые len/2 элементов"], "correctIndex": 1}, {"id": 7, "text": "Как безопасно получить значение из map и понять, был ли ключ?", "options": ["v := m[k]; if v==0 ...", "v, ok := m[k]", "ok := m.has(k)", "m.get(k, &v)"], "correctIndex": 1}, {"id": 8, "text": "Когда предпочтительнее использовать pointer receiver у метода структуры?", "options": ["Только если метод ничего не возвращает", "Если метод изменяет состояние структуры или структура большая", "Только если структура содержит map", "Всегда запрещено"], "correctIndex": 1}, {"id": 9, "text": "Как Go определяет, что тип реализует интерфейс?", "options": ["Через ключевое слово implements", "Через явную регистрацию в init()", "Неявно — если у типа есть нужные методы", "Только через embedding"], "correctIndex": 2}, {"id": 10, "text": "Какая идиоматичная форма оборачивания ошибки в Go?", "options": ["errors.Wrap(err, msg)", "fmt.Errorf(\"%w: ...\", err)", "fmt.Errorf(\"context: %w\", err)", "panic(err)"], "correctIndex": 2}, {"id": 11, "text": "Какой интерфейс лежит в основе большинства I/O-компонентов Go и читает данные в буфер?", "options": ["io.Closer", "io.Reader", "io.Scanner", "io.Stream"], "correctIndex": 1}, {"id": 12, "text": "Почему bufio.Writer требует вызова Flush()?", "options": ["Чтобы закрыть файл", "Чтобы данные из буфера гарантированно записались в нижележащий writer", "Чтобы установить кодировку", "Потому что иначе gofmt не пройдет"], "correctIndex": 1}, {"id": 13, "text": "Какая функция удобна для копирования данных из Reader в Writer потоком?", "options": ["fmt.Copy", "os.Copy", "io.Copy", "bufio.Copy"], "correctIndex": 2}, {"id": 14, "text": "Что возвращает len(s) для строки в Go?", "options": ["Количество Unicode-символов", "Количество байт в строке", "Количество слов", "Количество рун всегда"], "correctIndex": 1}, {"id": 15, "text": "Как корректно обработать конец потока при чтении?", "options": ["Считать io.EOF обычной ошибкой", "При err == io.EOF завершить чтение и считать это нормальным завершением", "Игнорировать любое err", "Вызвать panic при io.EOF"], "correctIndex": 1}, {"id": 16, "text": "Какая команда запускает тесты всех пакетов модуля рекурсивно?", "options": ["go test all", "go test ./...", "go test -all", "go run test"], "correctIndex": 1}, {"id": 17, "text": "Какой формат времени используется как 'эталон' при time.Parse/time.Format?", "options": ["2000-01-01 00:00:00", "1970-01-01 00:00:00", "2006-01-02 15:04:05", "YYYY-MM-DD HH:MM:SS"], "correctIndex": 2}, {"id": 18, "text": "Что делает io.LimitReader(r, n)?", "options": ["Шифрует поток", "Ограничивает чтение максимум n байт", "Ускоряет чтение", "Делает буферизацию"], "correctIndex": 1}, {"id": 19, "text": "Какой подход предпочтителен для больших JSON-файлов?", "options": ["json.Unmarshal всего файла в память", "json.NewDecoder и Decode потоково", "fmt.Sscan по строкам", "regexp для парсинга"], "correctIndex": 1}, {"id": 20, "text": "Какое утверждение про Scanner верно?", "options": ["Scanner гарантированно читает строки любой длины без настройки", "Scanner имеет лимит на размер токена, который нужно учитывать", "Scanner работает только с stdout", "Scanner нельзя применять к файлам"], "correctIndex": 1}, {"id": 21, "text": "Что такое goroutine?", "options": ["Поток ОС (OS thread)", "Легковесная единица конкурентного выполнения, управляемая рантаймом Go", "Процесс в Linux", "Только синтаксический сахар для for"], "correctIndex": 1}, {"id": 22, "text": "Как корректно завершить worker pool при наличии канала задач?", "options": ["Никогда не закрывать канал", "Закрыть канал задач и дождаться WaitGroup", "Вызвать runtime.GC()", "Использовать panic для остановки"], "correctIndex": 1}, {"id": 23, "text": "Для чего применяется select в Go?", "options": ["Для сортировки срезов", "Для выбора готовой операции среди нескольких каналов", "Для выбора типа переменной", "Для выбора пакета импорта"], "correctIndex": 1}, {"id": 24, "text": "Зачем нужен context.Context в конкурентном коде?", "options": ["Для форматирования логов", "Для отмены, дедлайнов и передачи request-scoped значений", "Для ускорения компиляции", "Для хранения глобальных переменных"], "correctIndex": 1}, {"id": 25, "text": "Какой инструмент помогает обнаруживать гонки данных?", "options": ["go fmt", "go test -race", "go vet -o race", "go build -O2"], "correctIndex": 1}, {"id": 26, "text": "Почему map нельзя безопасно читать/писать из нескольких goroutine без синхронизации?", "options": ["Потому что map всегда nil", "Потому что runtime может panic при конкурентной записи/чтении", "Потому что map медленный", "Потому что map копируется по значению"], "correctIndex": 1}, {"id": 27, "text": "Какой примитив синхронизации подходит для ожидания завершения группы goroutine?", "options": ["sync.Mutex", "sync.WaitGroup", "sync.Once", "sync.Cond"], "correctIndex": 1}, {"id": 28, "text": "Что делает middleware в HTTP-сервисе?", "options": ["Меняет версию Go", "Оборачивает обработчик, добавляя общую функциональность (логирование, таймауты и т.п.)", "Гарантирует отсутствие ошибок", "Шифрует весь трафик без настроек"], "correctIndex": 1}, {"id": 29, "text": "Какой код чаще всего используют для 'graceful shutdown' HTTP-сервера?", "options": ["os.Exit(0) без ожидания", "http.Server.Shutdown(ctx)", "panic(\"shutdown\")", "runtime.Goexit()"], "correctIndex": 1}, {"id": 30, "text": "Какая практика повышает надежность HTTP-клиента/сервиса в production?", "options": ["Не использовать таймауты", "Использовать таймауты и контекст, ограничивать ресурсы", "Делать все запросы синхронно", "Отключить обработку ошибок"], "correctIndex": 1}];

  // ====== STATE ======
  let remaining = TEST.durationSec;
  let timerId = null;
  const answers = new Map(); // qid -> chosenIndex

  // ====== HELPERS ======
  const pad2 = (n) => String(n).padStart(2, "0");
  const fmtTime = (sec) => `${pad2(Math.floor(sec / 60))}:${pad2(sec % 60)}`;

  function setTimerBadge() {
    const badge = document.getElementById("timerBadge");
    badge.textContent = `⏱ ${fmtTime(remaining)}`;

    badge.classList.remove("text-bg-info", "text-bg-warning", "text-bg-danger");
    if (remaining <= 60) badge.classList.add("text-bg-danger");
    else if (remaining <= 5 * 60) badge.classList.add("text-bg-warning");
    else badge.classList.add("text-bg-info");
  }

  function startTimer() {
    stopTimer();
    remaining = TEST.durationSec;
    setTimerBadge();
    timerId = setInterval(() => {
      remaining--;
      setTimerBadge();
      if (remaining <= 0) {
        stopTimer();
        finishTest(true);
      }
    }, 1000);
  }

  function stopTimer() {
    if (timerId) clearInterval(timerId);
    timerId = null;
  }

  function renderQuestions() {
    const wrap = document.getElementById("questions");
    wrap.innerHTML = "";

    questionsData.forEach((q) => {
      const card = document.createElement("div");
      card.className = "card rounded-4 shadow-sm mb-3 question-card";
      card.id = `q${q.id}`;

      const body = document.createElement("div");
      body.className = "card-body p-4";

      body.innerHTML = `
        <div class="d-flex flex-wrap justify-content-between gap-2 align-items-start">
          <h3 class="h6 mb-2">Вопрос ${q.id} из ${TEST.totalQuestions}</h3>
          <a class="small text-decoration-none" href="#top">Наверх</a>
        </div>
        <p class="mb-3">${q.text}</p>
        <div class="vstack gap-2" role="radiogroup" aria-label="Варианты ответа">
          ${q.options.map((opt, idx) => `
            <label class="border rounded-4 p-3 d-flex gap-2 align-items-start">
              <input class="form-check-input mt-1" type="radio" name="q_${q.id}" value="${idx}">
              <span>${opt}</span>
            </label>
          `).join("")}
        </div>
      `;

      card.appendChild(body);
      wrap.appendChild(card);

      const chosen = answers.get(q.id);
      if (chosen !== undefined) {
        const radio = card.querySelector(`input[type="radio"][value="${chosen}"]`);
        if (radio) radio.checked = true;
      }

      card.addEventListener("change", (e) => {
        const t = e.target;
        if (t && t.matches('input[type="radio"]')) {
          answers.set(q.id, Number(t.value));
        }
      });
    });
  }

  function calculate() {
    let correct = 0;
    questionsData.forEach((q) => {
      const chosen = answers.get(q.id);
      if (chosen === q.correctIndex) correct++;
    });
    const percent = Math.round((correct / TEST.totalQuestions) * 100);
    const passed = percent >= TEST.passPercent;
    return { correct, percent, passed };
  }

  function finishTest(isAuto = false) {
    stopTimer();
    const { correct, percent, passed } = calculate();

    document.getElementById("resCorrect").textContent = String(correct);
    document.getElementById("resTotal").textContent = String(TEST.totalQuestions);
    document.getElementById("resPercent").textContent = String(percent);
    document.getElementById("resStatus").textContent = passed ? "Зачёт" : "Не зачёт";

    const hint = document.getElementById("resHint");
    if (passed) {
      hint.textContent = "Зачёт. Можно переходить к следующему модулю.";
    } else {
      hint.textContent = "Не зачёт. Рекомендуется повторить материалы и пройти тест ещё раз.";
    }

    const modal = new bootstrap.Modal(document.getElementById("resultModal"));
    modal.show();
  }

  function resetTest() {
    answers.clear();
    renderQuestions();
    startTimer();
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  // ====== INIT ======
  document.getElementById("metaQuestions").textContent = TEST.totalQuestions;
  document.getElementById("metaTime").textContent = fmtTime(TEST.durationSec);
  document.getElementById("metaPass").textContent = TEST.passPercent + "%";
  setTimerBadge();

  renderQuestions();
  startTimer();

  document.getElementById("btnFinish").addEventListener("click", () => finishTest(false));
  document.getElementById("btnReset").addEventListener("click", () => resetTest());
</script>
</body>
</html>
